<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <meta name="description" content="Practice multiple choice questions with instant feedback.">
  <title>WSC Quizzer</title>
  <style>
    :root {
      --primary: #2a7ae2;
      --secondary: #f5f5f5;
      --accent: #e23a2a;
      --radius: 8px;
      --font: 'Segoe UI', Arial, sans-serif;
    }
    body {
      font-family: var(--font);
      background: var(--secondary);
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      justify-content: flex-start;
    }
    .sidebar {
      width: 300px;
      background: #fff;
      margin: 2rem 0 2rem 2rem;
      padding: 2rem;
      border-radius: var(--radius);
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
      height: fit-content;
      position: sticky;
      top: 2rem;
    }
    main {
      background: #fff;
      margin: 2rem 2rem 2rem 0;
      padding: 2rem;
      border-radius: var(--radius);
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
      max-width: 920px;
      width: 100%;
      flex: 1;
    }
    .question-layout {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 280px;
      gap: 1.25rem;
      align-items: start;
    }
    .question-main {
      min-width: 0;
    }
    .explanation-panel {
      border: 1px solid #dbe7f7;
      border-radius: var(--radius);
      background: #f7fbff;
      padding: 1rem;
    }
    .explanation-panel h2 {
      color: var(--primary);
      font-size: 1rem;
      margin: 0 0 0.5rem 0;
    }
    .explanation-panel p {
      margin: 0;
      line-height: 1.45;
      white-space: pre-wrap;
    }
    h1 {
      text-align: center;
      color: var(--primary);
      font-size: 2rem;
      margin-bottom: 1.5rem;
    }
    .question {
      font-size: 1.2rem;
      margin-bottom: 1.2rem;
    }
    .choices {
      list-style: none;
      padding: 0;
      margin: 0 0 1.2rem 0;
    }
    .choices li {
      margin-bottom: 0.7rem;
    }
    .choice-btn {
      width: 100%;
      padding: 0.7em 1em;
      border: 1px solid #ccc;
      border-radius: var(--radius);
      background: #f9f9f9;
      color: #333;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s, border 0.2s, color 0.2s;
    }
    .choice-btn[aria-pressed="true"] {
      background: var(--primary);
      color: #fff;
      border-color: var(--primary);
    }
    .choice-btn.correct {
      background: #4caf50;
      color: #fff;
      border-color: #4caf50;
    }
    .choice-btn.incorrect {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }
    .feedback {
      margin: 1rem 0;
      font-weight: bold;
      min-height: 1.5em;
    }
    .actions {
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
      margin-top: 1.5rem;
    }
    button {
      font-size: 1rem;
      padding: 0.6em 1.2em;
      border-radius: var(--radius);
      border: none;
      background: var(--primary);
      color: #fff;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .topic-list {
      margin-bottom: 1.5rem;
    }
    .category-filters {
      margin-bottom: 1.5rem;
      border: 1px solid #e0e0e0;
      border-radius: var(--radius);
      padding: 0.75rem 1rem 1rem;
    }
    .category-filters legend {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--primary);
    }
    .category-option {
      display: flex;
      align-items: center;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      gap: 0.5rem;
    }
    .topic-item {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
      padding: 0.5rem;
      border-radius: var(--radius);
      cursor: pointer;
      transition: background 0.2s;
    }
    .topic-item:hover:not(.disabled) {
      background: #f0f0f0;
    }
    .topic-item.selected {
      background: var(--primary);
      color: white;
    }
    .topic-item.disabled {
      color: #999;
      cursor: not-allowed;
    }
    .topic-checkbox {
      margin-right: 0.5rem;
      width: 16px;
      height: 16px;
    }
    .topic-name {
      flex: 1;
      font-size: 0.9rem;
    }
    .topic-count {
      font-size: 0.8rem;
      color: #666;
      margin-left: 0.5rem;
    }
    .topic-item.selected .topic-count {
      color: rgba(255,255,255,0.8);
    }
    .topic-item.disabled .topic-count {
      color: #ccc;
    }
    .ask-button {
      width: 100%;
      padding: 0.8rem;
      font-size: 1rem;
      font-weight: bold;
    }
    @media (max-width: 900px) {
      body {
        flex-direction: column;
      }
      .sidebar {
        width: 100%;
        margin: 1rem;
        position: static;
      }
      main {
        margin: 0 1rem 1rem 1rem;
      }
      .question-layout {
        grid-template-columns: 1fr;
      }
    }
    @media (max-width: 600px) {
      .sidebar, main {
        padding: 1rem;
        margin: 0.5rem;
      }
      h1 {
        font-size: 1.3rem;
      }
    }
  </style>
</head>
<body>
  <aside class="sidebar">
    <h2 style="margin-top: 0; color: var(--primary); font-size: 1.2rem;">Select Topics</h2>
    <fieldset class="category-filters">
      <legend>Question Type</legend>
      <label class="category-option">
        <input type="radio" name="category-filter" value="challenge" checked>
        Challenge questions
      </label>
      <label class="category-option">
        <input type="radio" name="category-filter" value="single">
        Single topic
      </label>
      <label class="category-option">
        <input type="radio" name="category-filter" value="all">
        All questions
      </label>
    </fieldset>
    <div style="margin-bottom: 1rem;">
      <button id="select-all-button" style="margin-right: 0.5rem; padding: 0.4rem 0.8rem; font-size: 0.9rem; border: none; border-radius: var(--radius); background: var(--primary); color: white; cursor: pointer;">Select All</button>
      <button id="unselect-all-button" style="padding: 0.4rem 0.8rem; font-size: 0.9rem; border: none; border-radius: var(--radius); background: #666; color: white; cursor: pointer;">Unselect All</button>
    </div>
    <div class="topic-list" id="topic-list"></div>
    <button id="ask-button" class="ask-button" disabled>Ask me about these</button>
  </aside>
  <main>
    <h1>Question Generator</h1>
    <section id="question-section" aria-live="polite" style="display:none;">
      <div class="question-layout">
        <div class="question-main">
          <div class="question" id="question-text"></div>
          <ul class="choices" id="choices-list"></ul>
          <div class="feedback" id="feedback" aria-live="assertive"></div>
          <div class="actions">
            <button id="skip-btn" type="button">Skip Question</button>
            <button id="show-answer-btn" type="button" style="display:none;">Show Answer</button>
            <button id="explain-btn" type="button">Explain</button>
            <button id="next-btn" type="button" style="display:none;">Next Question</button>
          </div>
        </div>
        <aside class="explanation-panel" id="explanation-panel" style="display:none;">
          <h2>Explanation</h2>
          <p id="explanation-text"></p>
        </aside>
      </div>
    </section>
    <div id="loading" style="text-align:center; margin-top:1.5rem;">Loading questions...</div>
    <div id="error" style="color:var(--accent); text-align:center; display:none;"></div>
    <div id="welcome-message" style="text-align:center; margin-top:1.5rem; display:none;">
      <h2>Welcome to the WSC Quizzer!</h2>
      <p>Select topics from the list on the left to begin your quiz.</p>
      <p>Choose one or more topics, then click "Ask me about these" to start.</p>
    </div>
  </main>
  <script>
    // Accessibility: focus management helpers
    function focusFirstChoice() {
      const first = document.querySelector('.choice-btn');
      if (first) first.focus();
    }


    // State
    let questions = [];
    let allQuestions = []; // Store all questions for topic filtering
    let currentIndex = -1;
    let currentQuestion = null;
    let hasAnswered = false;
    let answeredQuestionIds = new Set(); // Track answered questions by ID (all-time)
    let skippedQuestionIds = new Set(); // Track skipped questions by ID (all-time)
    let currentQuestionIds = new Set(); // Track unique questions in the current quiz
    let sessionAnsweredIds = new Set(); // Track answers within the current quiz session
    let sessionSkippedIds = new Set(); // Track skips within the current quiz session
    let reviewedSkippedIds = new Set(); // Track skipped questions that have been reviewed
    let isInReviewMode = false; // Track if we're in review mode
    let selectedTopics = new Set(); // Track selected topics
    let topicQuestionCounts = {}; // Count questions per topic
    let topicNames = []; // Derived from question-pool.jsonl topics fields
    let selectedCategoryFilter = 'challenge';

    // Elements
    const questionText = document.getElementById('question-text');
    const choicesList = document.getElementById('choices-list');
    const feedback = document.getElementById('feedback');
    const skipBtn = document.getElementById('skip-btn');
    const showAnswerBtn = document.getElementById('show-answer-btn');
    const explainBtn = document.getElementById('explain-btn');
    const nextBtn = document.getElementById('next-btn');
    const explanationPanel = document.getElementById('explanation-panel');
    const explanationText = document.getElementById('explanation-text');
    const loading = document.getElementById('loading');
    const errorDiv = document.getElementById('error');
    const topicList = document.getElementById('topic-list');
    const askButton = document.getElementById('ask-button');
    const selectAllButton = document.getElementById('select-all-button');
    const unselectAllButton = document.getElementById('unselect-all-button');
    const categoryFilterRadios = document.querySelectorAll('input[name="category-filter"]');

    const CATEGORY_FILTER_MAP = {
      challenge: new Set(['comparative_consequences', 'thematic_synthesis', 'context_clues']),
      single: new Set(['single_topic_understanding']),
      all: null
    };

    function deriveTopicNames(sourceQuestions = allQuestions) {
      const uniqueTopics = new Set();
      sourceQuestions.forEach(question => {
        if (question.topics && Array.isArray(question.topics)) {
          question.topics.forEach(topic => {
            if (typeof topic === 'string' && topic.trim()) {
              uniqueTopics.add(topic.trim());
            }
          });
        }
      });
      topicNames = Array.from(uniqueTopics).sort((a, b) => a.localeCompare(b));
    }

    function buildQuestionId(parsedQuestion, lineIndex) {
      if (parsedQuestion.id && typeof parsedQuestion.id === 'string' && parsedQuestion.id.trim()) {
        return parsedQuestion.id.trim();
      }
      const base = [
        parsedQuestion.category || '',
        parsedQuestion.question || '',
        Array.isArray(parsedQuestion.choices) ? parsedQuestion.choices.join('|') : '',
        Array.isArray(parsedQuestion.topics) ? parsedQuestion.topics.join('|') : '',
        String(lineIndex)
      ].join('::');
      return `q-${btoa(unescape(encodeURIComponent(base))).replace(/=+$/,'')}`;
    }

    // Fetch and parse JSONL from local file
    async function loadQuestions() {
      try {
        const resp = await fetch('question-pool.jsonl');
        if (!resp.ok) throw new Error('Could not load question pool.');
        const text = await resp.text();
        allQuestions = text
          .split('\n')
          .map(line => line.trim())
          .filter(Boolean)
          .map((line, index) => {
            try {
              const parsed = JSON.parse(line);
              // Convert letter answer (A, B, C, etc.) to numeric index
              if (parsed.correct && typeof parsed.correct === 'string') {
                parsed.answer = parsed.correct.charCodeAt(0) - 65; // A=0, B=1, C=2, etc.
              }
              parsed.id = buildQuestionId(parsed, index);
              return parsed;
            } catch {
              return null;
            }
          })
          .filter(q => q && q.question && Array.isArray(q.choices) && typeof q.answer !== 'undefined');
        
        if (allQuestions.length === 0) throw new Error('No valid questions found.');

        deriveTopicNames(allQuestions);
        if (topicNames.length === 0) throw new Error('No topics found in question pool.');

        // Build topic counts and create topic list
        createTopicList();
        
        loading.style.display = 'none';
        document.getElementById('welcome-message').style.display = 'block';
        // Don't show questions until topics are selected
      } catch (e) {
        loading.style.display = 'none';
        errorDiv.style.display = 'block';
        errorDiv.textContent = e.message;
      }
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function getQuestionsMatchingCategory() {
      const allowedCategories = CATEGORY_FILTER_MAP[selectedCategoryFilter];
      if (!allowedCategories) {
        return allQuestions;
      }
      return allQuestions.filter(question => allowedCategories.has(question.category));
    }

    // Build counts of questions per topic
    function buildTopicCounts(sourceQuestions = allQuestions) {
      topicQuestionCounts = {};
      sourceQuestions.forEach(question => {
        if (question.topics && Array.isArray(question.topics)) {
          question.topics.forEach(topic => {
            topicQuestionCounts[topic] = (topicQuestionCounts[topic] || 0) + 1;
          });
        }
      });
    }

    // Create the topic list UI
    function createTopicList({ preserveSelection = false } = {}) {
      const previousSelection = new Set(selectedTopics);
      selectedTopics.clear();
      topicList.innerHTML = '';

      const categoryFilteredQuestions = getQuestionsMatchingCategory();
      buildTopicCounts(categoryFilteredQuestions);

      topicNames.forEach(topicName => {
        const count = topicQuestionCounts[topicName] || 0;
        const topicItem = document.createElement('div');
        const isSelectable = count > 0;
        const shouldSelect = isSelectable && (
          (preserveSelection && previousSelection.has(topicName)) ||
          (!preserveSelection)
        );

        if (shouldSelect) {
          selectedTopics.add(topicName);
        }

        const checkboxAttributes = [
          'type="checkbox"',
          'class="topic-checkbox"',
          !isSelectable ? 'disabled' : '',
          shouldSelect ? 'checked' : ''
        ].filter(Boolean).join(' ');

        topicItem.className = 'topic-item';
        if (!isSelectable) {
          topicItem.classList.add('disabled');
        } else if (shouldSelect) {
          topicItem.classList.add('selected');
        }

        topicItem.innerHTML = `
          <input ${checkboxAttributes} />
          <span class="topic-name">${topicName}</span>
          <span class="topic-count">(${count})</span>
        `;

        if (isSelectable) {
          topicItem.addEventListener('click', () => toggleTopic(topicName, topicItem));
        }

        topicList.appendChild(topicItem);
      });

      // Update ask button state
      askButton.disabled = selectedTopics.size === 0;
    }

    // Toggle topic selection
    function toggleTopic(topicName, topicItem) {
      const checkbox = topicItem.querySelector('.topic-checkbox');
      const isSelected = selectedTopics.has(topicName);
      
      if (isSelected) {
        selectedTopics.delete(topicName);
        topicItem.classList.remove('selected');
        checkbox.checked = false;
      } else {
        selectedTopics.add(topicName);
        topicItem.classList.add('selected');
        checkbox.checked = true;
      }
      
      // Enable/disable ask button based on selection
      askButton.disabled = selectedTopics.size === 0;
    }

    // Filter questions by selected topics
    function filterQuestionsByTopics() {
      if (selectedTopics.size === 0) {
        questions = [];
        return;
      }

      questions = allQuestions.filter(question => {
        if (!question.topics || !Array.isArray(question.topics)) {
          return false;
        }
        const matchesTopic = question.topics.some(topic => selectedTopics.has(topic));
        if (!matchesTopic) {
          return false;
        }
        const allowedCategories = CATEGORY_FILTER_MAP[selectedCategoryFilter];
        if (!allowedCategories) {
          return true;
        }
        return allowedCategories.has(question.category);
      });
    }

    // Select all topics with questions
    function selectAllTopics() {
      const topicItems = document.querySelectorAll('.topic-item:not(.disabled)');
      topicItems.forEach(item => {
        const topicName = item.querySelector('.topic-name').textContent;
        selectedTopics.add(topicName);
        item.classList.add('selected');
        item.querySelector('.topic-checkbox').checked = true;
      });
      askButton.disabled = selectedTopics.size === 0;
    }

    // Unselect all topics
    function unselectAllTopics() {
      const topicItems = document.querySelectorAll('.topic-item');
      topicItems.forEach(item => {
        const topicName = item.querySelector('.topic-name').textContent;
        selectedTopics.delete(topicName);
        item.classList.remove('selected');
        item.querySelector('.topic-checkbox').checked = false;
      });
      askButton.disabled = selectedTopics.size === 0;
    }

    // Start quiz with selected topics
    function rebuildCurrentQuestionIds() {
      currentQuestionIds = new Set();
      questions.forEach(question => {
        if (question.id) {
          currentQuestionIds.add(question.id);
        }
      });
    }

    function startQuizWithTopics() {
      // Clear review mode flag
      isInReviewMode = false;
      filterQuestionsByTopics();
      if (questions.length === 0) {
        alert('No questions available for the selected topics.');
        return;
      }
      // Reset per-session tracking for the new quiz run
      rebuildCurrentQuestionIds();
      sessionAnsweredIds = new Set();
      sessionSkippedIds = new Set();
      reviewedSkippedIds.clear();
      // Don't clear answeredQuestionIds here - preserve answered questions
      document.getElementById('welcome-message').style.display = 'none';
      document.getElementById('question-section').style.display = 'block';
      showNextQuestion();
    }

    // Start reviewing skipped questions
    function startSkippedQuestionsReview() {
      // Set review mode flag
      isInReviewMode = true;
      // Reset reviewed tracking for skipped questions
      reviewedSkippedIds.clear();
      // Restore the full question set from the original filtered questions
      filterQuestionsByTopics();
      rebuildCurrentQuestionIds();
      if (questions.length === 0) {
        alert('No skipped questions to review.');
        return;
      }
      document.getElementById('question-section').style.display = 'block';
      showNextQuestion();
    }

    function showNextQuestion() {
      feedback.textContent = '';
      skipBtn.style.display = 'inline-block';
      showAnswerBtn.style.display = 'none';
      showAnswerBtn.textContent = 'Show Answer';
      showAnswerBtn.dataset.mode = 'show-answer';
      explainBtn.style.display = 'inline-block';
      nextBtn.style.display = 'none';
      explanationPanel.style.display = 'none';
      explanationText.textContent = '';
      hasAnswered = false;

      let availableQuestions;
      if (isInReviewMode) {
        // In review mode, show skipped questions that haven't been reviewed yet
        availableQuestions = questions.filter(q =>
          sessionSkippedIds.has(q.id) && !reviewedSkippedIds.has(q.id)
        );
      } else {
        // Get questions that haven't been answered or skipped yet
        availableQuestions = questions.filter(q =>
          !sessionAnsweredIds.has(q.id) && !sessionSkippedIds.has(q.id)
        );
      }
      
      // Check if all questions have been completed
      if (availableQuestions.length === 0) {
        if (isInReviewMode) {
          // All skipped questions have been answered, go back to completion
          isInReviewMode = false;
          filterQuestionsByTopics(); // Restore full question set
          rebuildCurrentQuestionIds();
          showCompletionMessage();
        } else {
          showCompletionMessage();
        }
        return;
      }

      // Pick a random question from available ones
      currentIndex = Math.floor(Math.random() * availableQuestions.length);
      currentQuestion = availableQuestions[currentIndex];

      // Shuffle choices for fairness
      const choices = shuffle([...currentQuestion.choices]);
      questionText.textContent = currentQuestion.question;
      choicesList.innerHTML = '';
      choices.forEach((choice, idx) => {
        const li = document.createElement('li');
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'choice-btn';
        btn.setAttribute('aria-pressed', 'false');
        btn.setAttribute('tabindex', '0');
        btn.textContent = choice;
        btn.addEventListener('click', () => handleChoice(btn, choice));
        li.appendChild(btn);
        choicesList.appendChild(li);
      });
      focusFirstChoice();
    }

    function markCurrentQuestionAnswered() {
      if (currentQuestion && currentQuestion.id) {
        answeredQuestionIds.add(currentQuestion.id);
        sessionAnsweredIds.add(currentQuestion.id);
        skippedQuestionIds.delete(currentQuestion.id);
        sessionSkippedIds.delete(currentQuestion.id);
      }
    }

    function revealCorrectAnswer() {
      hasAnswered = true;
      const correct = currentQuestion.choices[currentQuestion.answer];
      const btns = document.querySelectorAll('.choice-btn');
      btns.forEach(b => {
        b.disabled = true;
        if (b.textContent === correct) {
          b.classList.add('correct');
        }
      });
      feedback.textContent = `The correct answer is: "${correct}".`;
      skipBtn.style.display = 'none';
      showAnswerBtn.style.display = 'none';
      nextBtn.style.display = 'inline-block';
      markCurrentQuestionAnswered();
    }

    function handleChoice(btn, selectedChoice) {
      // Find correct answer text
      const correct = currentQuestion.choices[currentQuestion.answer];
      const btns = document.querySelectorAll('.choice-btn');
      
      // Clear previous selections and feedback
      btns.forEach(b => {
        b.classList.remove('incorrect', 'correct');
        b.setAttribute('aria-pressed', 'false');
      });
      feedback.textContent = '';
      skipBtn.style.display = 'none';
      showAnswerBtn.style.display = 'none';
      nextBtn.style.display = 'none';
      
      if (btn.textContent === correct) {
        // Correct answer - disable all buttons and show success
        hasAnswered = true;
        btns.forEach(b => b.disabled = true);
        btn.classList.add('correct');
        btn.setAttribute('aria-pressed', 'true');
        feedback.textContent = 'Correct!';
        nextBtn.style.display = 'inline-block';
        markCurrentQuestionAnswered();
      } else {
        // Wrong answer - keep buttons enabled for retry
        btn.classList.add('incorrect');
        btn.setAttribute('aria-pressed', 'true');
        feedback.textContent = 'Incorrect. Try another answer or "Show Answer" if you\'re stuck.';
        showAnswerBtn.style.display = 'inline-block';
      }
    }

    function showCompletionMessage() {
      const totalQuestions = currentQuestionIds.size || questions.length;
      const answeredCount = sessionAnsweredIds.size;
      const skippedCount = sessionSkippedIds.size;
      const hasSkippedQuestions = skippedCount > 0;
      
      questionText.innerHTML = `
        <div style="text-align: center; padding: 2rem 0;">
          <h2 style="color: var(--primary); margin-bottom: 1rem;">ðŸŽ‰ Quiz Complete!</h2>
          <p style="font-size: 1.1rem; margin-bottom: 1rem;">
            You've completed all ${totalQuestions} questions from your selected topics!
          </p>
          <p style="margin-bottom: 0.5rem;">
            <strong>Questions answered: ${answeredCount}/${totalQuestions}</strong>
          </p>
          <p style="margin-bottom: 2rem;">
            <strong>Questions skipped: ${skippedCount}/${totalQuestions}</strong>
          </p>
          <button id="back-to-skipped-btn" style="
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.8rem 2rem;
            border-radius: var(--radius);
            font-size: 1rem;
            cursor: pointer;
            margin-right: 1rem;
            ${!hasSkippedQuestions ? 'opacity: 0.5; cursor: not-allowed;' : ''}
          " ${!hasSkippedQuestions ? 'disabled' : ''}>Back to Skipped Questions</button>
          <button id="new-topics-btn" style="
            background: var(--accent);
            color: white;
            border: none;
            padding: 0.8rem 2rem;
            border-radius: var(--radius);
            font-size: 1rem;
            cursor: pointer;
          ">Change Topic Selection</button>
        </div>
      `;
      
      choicesList.innerHTML = '';
      feedback.textContent = '';
      skipBtn.style.display = 'none';
      showAnswerBtn.style.display = 'none';
      explainBtn.style.display = 'none';
      nextBtn.style.display = 'none';
      explanationPanel.style.display = 'none';
      explanationText.textContent = '';
      
      // Add event listeners for the new buttons
      const backToSkippedBtn = document.getElementById('back-to-skipped-btn');
      if (hasSkippedQuestions) {
        backToSkippedBtn.addEventListener('click', () => {
          startSkippedQuestionsReview();
        });
      }
      
      document.getElementById('new-topics-btn').addEventListener('click', () => {
        // Allow changing topics while preserving answered questions
        document.getElementById('question-section').style.display = 'none';
        document.getElementById('welcome-message').style.display = 'block';
      });
    }

    skipBtn.addEventListener('click', () => {
      // Mark current question as skipped when skipped
      if (currentQuestion && currentQuestion.id) {
        if (isInReviewMode) {
          // In review mode, mark as reviewed so it won't show again
          reviewedSkippedIds.add(currentQuestion.id);
        } else {
          // In normal mode, mark as skipped
          skippedQuestionIds.add(currentQuestion.id);
          sessionSkippedIds.add(currentQuestion.id);
        }
      }
      showNextQuestion();
    });

    showAnswerBtn.addEventListener('click', () => {
      if (showAnswerBtn.dataset.mode === 'next-question') {
        showNextQuestion();
        return;
      }

      revealCorrectAnswer();
    });

    explainBtn.addEventListener('click', () => {
      revealCorrectAnswer();

      const explanationValue =
        currentQuestion && typeof currentQuestion.explanation === 'string'
          ? currentQuestion.explanation.trim()
          : '';
      explanationText.textContent = explanationValue || 'No explanation provided for this question.';
      explanationPanel.style.display = 'block';

      nextBtn.style.display = 'none';
      showAnswerBtn.textContent = 'Next Question';
      showAnswerBtn.dataset.mode = 'next-question';
      showAnswerBtn.style.display = 'inline-block';
    });

    nextBtn.addEventListener('click', () => {
      showNextQuestion();
    });

    // Keyboard accessibility: allow Enter/Space to select
    choicesList.addEventListener('keydown', e => {
      if (e.target.classList.contains('choice-btn') && (e.key === 'Enter' || e.key === ' ')) {
        e.preventDefault();
        e.target.click();
      }
    });

    // Event listeners
    askButton.addEventListener('click', startQuizWithTopics);
    selectAllButton.addEventListener('click', selectAllTopics);
    unselectAllButton.addEventListener('click', unselectAllTopics);
    categoryFilterRadios.forEach(radio => {
      radio.addEventListener('change', () => {
        if (radio.checked) {
          selectedCategoryFilter = radio.value;
          createTopicList({ preserveSelection: true });
        }
      });
    });

    // Initial load
    window.addEventListener('DOMContentLoaded', loadQuestions);
  </script>
</body>
</html>
